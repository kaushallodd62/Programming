{\rtf1\ansi\ansicpg1252\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww15200\viewh7740\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs36 \cf0 Kaushal Lodd\
Daily Report - 21/05/22 Sat\
\
1. Stacks \
	a. Content covered before 21/05/22:\
		- stack in STL \
		- implementing queues using stacks\
\
	b. Content covered on 21/05/22:\
		- implementing stacks using queues (did it using a single queue)\
		- implementing two / k stacks in an array\
		- implementing stack using priority queue/max heap (store pair<value, count> in heap where count increments on every push())\
		- infix to postfix conversion (give precedence of operators priority number, and then push, pop based on priority conditions)\
		- infix to prefix conversion (reverse the expression and reverse \'91(\'91 to \'91)\'92 and vice verse, and then apply infix to postfix algorithm (with some changes) and then reverse the final output)\
		- prefix to infix conversion (read expression from right to left and put variables/numbers on stack and then pop top two operands when encountering an operator in the expression. Push the \'93op1 op op2\'94 string back to the stack and repeat)\
		- postfix to infix conversion (same algorithm as prefix to infix, except you read from left to right) \
\
2. Binary Trees\
	- introduction and some theory (reading)\
	- insertion (inserting into first node in level-order traversal that doesn\'92t have a left or right child)\
	- deletion (swapping the value of the node to be deleted with the deepest rightmost node and then deleting the deepest rightmost node)\
	- pre-order, in-order, post-order, level-order (accessing nodes level by level and left to right) traversals\
	- in-order traversal using stacks (without recursion)}